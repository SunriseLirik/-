1. Дискретные числовые признаки - это те, которые принимают конечное или ограниченное количество значений, например, количество детей в семье (0, 1, 2, 3 и т.д.) или пол человека (мужчина, женщина, неопределенный). Непрерывные числовые признаки принимают бесконечное количество значений в заданном диапазоне, например, рост человека или вес.

2. Обучение с учителем - это тип машинного обучения, при котором модель обучается на размеченных данных, то есть на примерах, где известны принадлежность данных к определенным классам или их значения. При обучении без учителя модели предоставляются только неразмеченные данные, и модель должна выявить в них закономерности и структуру самостоятельно.

3. Задачи классификации - это задачи, в которых модель должна присвоить входному образцу один из определенных классов. Например, определение пола человека или классификация письма как спамом или неспамом. Задачи регрессии - это задачи, в которых модель должна предсказать непрерывное значение на основе входных данных. Например, прогнозирование цены дома на основе его размеров и местоположения.

4. Задача определения кошки или собаки на основе изображения относится к задачам классификации машинного обучения.

5. Проверка модели на валидационных данных помогает оценить ее способность к обобщению на новые, не виденные ранее данные. Использование только тренировочных данных может привести к переобучению, когда модель слишком хорошо подстраивается под тренировочные данные, но плохо справляется с новыми данными.

6. Возможные матрицы, которые можно перемножить между собой, это:
    - A (5x4) и B (4x6) -> результат: матрица 5x6
    - A (5x4) и C (3x5) -> перемножение невозможно, так как число столбцов в первой матрице не равно числу строк во второй.
    - B (4x6) и C (3x5) -> перемножение невозможно, так как число столбцов в первой матрице не равно числу строк во второй.

7.Чтобы найти градиент функции f(x, y, z) = y*x^2 + ln(y) + e^-z, необходимо вычислить частные производные функции по каждой из переменных x, y, z.

1) Чтобы найти частную производную f по x:
df/dx = d(y*x^2)/dx + d(ln(y))/dx + d(e^-z)/dx
df/dx = 2*y*x + 0 + 0
df/dx = 2*y*x

2) Чтобы найти частную производную f по y:
df/dy = d(y*x^2)/dy + d(ln(y))/dy + d(e^-z)/dy
df/dy = x^2 + (1/y) + 0
df/dy = x^2 + 1/y

3) Чтобы найти частную производную f по z:
df/dz = d(y*x^2)/dz + d(ln(y))/dz + d(e^-z)/dz
df/dz = 0 + 0 - e^-z
df/dz = -e^-z

Таким образом, градиент функции f(x, y, z) равен:
∇f(x, y, z) = [2*y*x, x^2 + 1/y, -e^-z]

Для вычисления градиента функции ( f(x, y, z) = y \cdot x^2 + \ln(y) + e^{-z} ) в Python, можно использовать библиотеку numpy для математических операций и sympy для символьных вычислений, которые позволят нам найти частные производные по переменным ( x ), ( y ), и ( z ).

import numpy as np
import sympy as sp

# Определяем символы
x, y, z = sp.symbols('x y z')

# Определяем функцию
f = y * x**2 + sp.log(y) + sp.exp(-z)

# Вычисляем частные производные
df_dx = sp.diff(f, x)
df_dy = sp.diff(f, y)
df_dz = sp.diff(f, z)

# Выводим результаты
print("Частная производная по x:", df_dx)
print("Частная производная по y:", df_dy)
print("Частная производная по z:", df_dz)

# Функция для вычисления градиента
def gradient(x_val, y_val, z_val):
    # Подставляем значения в производные
    grad_x = df_dx.subs({x: x_val, y: y_val, z: z_val})
    grad_y = df_dy.subs({x: x_val, y: y_val, z: z_val})
    grad_z = df_dz.subs({x: x_val, y: y_val, z: z_val})
    return np.array([grad_x, grad_y, grad_z])

# Пример значений для x, y, z
x_val, y_val, z_val = 1, 2, 3

# Вычисление и вывод градиента
grad = gradient(x_val, y_val, z_val)
print("Градиент функции f при x = {}, y = {}, z = {}:".format(x_val, y_val, z_val), grad)
Объяснение кода:
-Символы и функция: Сначала мы определяем переменные x, y, z как символьные объекты библиотеки sympy. Затем мы определяем функцию ( f ), используя эти символы.
-Частные производные: Мы находим производные функции ( f ) по каждой из переменных с помощью функции diff библиотеки sympy.
-Функция gradient: Эта функция принимает конкретные значения для x, y, и z, подставляет их в полученные производные и возвращает градиент функции в виде массива NumPy.

8.Чтобы найти частные производные сложной функции E по переменным w и b, мы можем использовать цепное правило дифференцирования.
Пусть y' = w*x + b.
Тогда E = (y' - y)^2.
Частная производная E по w равна:
dE/dw = d((y' - y)^2)/dw.
Используя цепное правило, мы получаем:
dE/dw = 2 * (y' - y) * dy'/dw.
Теперь нам нужно найти dy'/dw. Используя тот факт, что y' = w * x + b, мы получаем:
dy'/dw = x.
Подставляя это в предыдущее уравнение, мы получаем:
dE/dw = 2 * (y' - y) * x.
Частная производная E по b равна:
dE/db = d((y' - y)^2)/db.
Используя цепное правило, мы получаем:
dE/db = 2 * (y' - y) * dy'/db.
Теперь нам нужно найти dy'/db. Используя тот факт, что y' = w * x + b, мы получаем:
dy'/db = 1.
Подставляя это в предыдущее уравнение, мы получаем:
dE/db = 2 * (y' - y).
В Python вы можете вычислить эти производные, используя следующий код:
def dE_dw(y, y_prime, x):
    return 2 * (y_prime - y) * x
def dE_db(y, y_prime):
    return 2 * (y_prime - y)
Обратите внимание, что в этой реализации предполагается, что y, y_prime, x являются скалярными значениями. Если они являются векторами, вам нужно будет соответствующим образом изменить реализацию.

9.  Найдите частные производные сложной функции 
E = y*ln(y') + (1-y)*ln(1-y'), y'=1/(1+e^(-z)) по переменной z. e - это основание натурального логарифма, y' - это предсказание модели y

import sympy as sp
# Определение переменных
z = sp.symbols('z')
y = sp.symbols('y')
# Определение y'
y_prime = 1 / (1 + sp.exp(-z))
# Определение функции E
E = y * sp.log(y_prime) + (1 - y) * sp.log(1 - y_prime)
# Вычисление частной производной E по z
dE_dz = sp.diff(E, z)
# Упрощение выражения
dE_dz_simplified = sp.simplify(dE_dz)
print(f'Частная производная E по z: {dE_dz_simplified}')
Этот код использует библиотеку sympy для символического вычисления частной производной функции ( E ) по переменной ( z ). Вывод будет выглядеть следующим образом:

Частная производная E по z: y*(1 - 1/(1 + exp(-z))) - (1 - y)/(1 + exp(-z))
