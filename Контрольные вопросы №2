1. Для считывания данных из файла iris.csv, который содержит значения, разделенные точкой с запятой (;), в датафрейм Pandas, вы можете использовать функцию read_csv из библиотеки Pandas. Важно указать правильный разделитель, поскольку по умолчанию read_csv ожидает запятую (,) в качестве разделителя. Также стоит присмотреться к пробелам после разделителей, если они есть в вашем файле.

Вот пример команды для считывания вашего файла:


import pandas as pd

# Загрузка данных из файла
file_path = '/data/iris.csv'
data = pd.read_csv(file_path, delimiter=';')

# Просмотр первых нескольких строк датафрейма
print(data.head())

Пояснение к коду:
-Импорт Pandas: Сначала мы импортируем библиотеку Pandas под псевдонимом pd.
-Путь к файлу: В переменной file_path сохраняется путь к файлу.
-Чтение файла: Функция pd.read_csv() используется для загрузки данных из файла. Аргумент delimiter=';' указывает, что в качестве разделителя полей в файле используется точка с запятой (;). Это важно, поскольку данные в вашем файле разделены точками с запятой, и если не указать этот параметр, Pandas не сможет правильно разделить столбцы.
-Просмотр данных: С помощью data.head(), вы можете просмотреть первые пять строк загруженного датафрейма, чтобы убедиться, что данные считаны корректно.

2. Для выполнения описанных операций в Python можно использовать библиотеку pandas. Вот пошаговое руководство:

Загрузите данные в DataFrame.
Удалите дубликаты.
Выберите строки с индекса 69 по 322.
Отсортируйте результат по колонке 'Distance' по убыванию.
Получите значение колонки 'Style' во второй строке после сортировки.
Пример кода:

import pandas as pd
# Шаг 1: Загрузка данных в DataFrame (предположим, что данные в файле 'cars.csv')
df = pd.read_csv('cars.csv')
# Шаг 2: Удаление дубликатов
df = df.drop_duplicates()
# Шаг 3: Выбор строк с индекса 69 по 322 (включительно)
subset_df = df.iloc[69:323]
# Шаг 4: Сортировка по колонке 'Distance' по убыванию
sorted_df = subset_df.sort_values(by='Distance', ascending=False)
# Шаг 5: Получение значения колонки 'Style' во второй строке сверху
second_row_style = sorted_df.iloc[1]['Style']
print(second_row_style)
Описание шагов:

-Импортируем библиотеку pandas.
-Загружаем данные из файла 'cars.csv' в DataFrame.
-Удаляем дубликаты с помощью метода drop_duplicates().
-Выбираем строки с 69 по 322 (обратите внимание, что iloc включает начальный индекс и исключает конечный индекс, поэтому используем 323).
-Сортируем DataFrame по колонке 'Distance' в порядке убывания (ascending=False).
-Получаем значение колонки 'Style' во второй строке после сортировки с помощью iloc[1].

3. Чтобы оценить количество строк, которые были удалены после анализа гистограмм распределения и удаления аномальных значений в наборе данных Cars, нужно выполнить следующие шаги:
-Загрузите данные в DataFrame.
-Постройте гистограммы для каждого интересующего столбца.
-Определите критерии для исключения аномальных значений.
-Удалите строки, соответствующие этим критериям.
-Подсчитайте количество удаленных строк.
Пример кода:

import pandas as pd
import matplotlib.pyplot as plt
# Шаг 1: Загрузка данных в DataFrame (предположим, что данные в файле 'cars.csv')
df = pd.read_csv('cars.csv')
# Шаг 2: Построение гистограмм для каждого интересующего столбца
columns_of_interest = ['Distance', 'Price', 'Age']  # Предположим, что эти столбцы являются интересующими
for column in columns_of_interest:
    plt.figure()
    df[column].hist(bins=50)
    plt.title(f'Histogram of {column}')
    plt.xlabel(column)
    plt.ylabel('Frequency')
    plt.show()
# Шаг 3: Определение критериев для исключения аномальных значений
# Здесь мы используем метод межквартильного диапазона (IQR) для определения аномалий
def remove_outliers(df, column):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    return df[(df[column] >= lower_bound) & (df[column] <= upper_bound)]
# Шаг 4: Удаление строк, соответствующих критериям
initial_row_count = df.shape[0]
for column in columns_of_interest:
    df = remove_outliers(df, column)
final_row_count = df.shape[0]
# Шаг 5: Подсчет количества удаленных строк
rows_removed = initial_row_count - final_row_count
print(f'Количество удаленных строк: {rows_removed}')
Описание шагов:
-Импортируйте необходимые библиотеки.
-Загрузите данные из файла 'cars.csv' в DataFrame.
-Постройте гистограммы для каждого интересующего столбца, чтобы визуально оценить распределение данных и выявить возможные аномалии.
-Определите критерии для исключения аномальных значений. В данном случае используется метод межквартильного диапазона (IQR).
-Напишите функцию remove_outliers, которая удаляет строки с аномальными значениями в указанном столбце.
-Подсчитайте количество строк до и после удаления аномалий, чтобы оценить количество удаленных строк.

4. Чтобы определить самую распространенную марку автомобилей в наборе данных Cars, можно использовать библиотеку pandas. Вот шаги, которые нужно выполнить:
-Загрузите данные в DataFrame.
-Подсчитайте количество появлений каждой марки.
-Определите марку с наибольшим количеством появлений.
Пример кода:

import pandas as pd
# Шаг 1: Загрузка данных в DataFrame (предположим, что данные в файле 'cars.csv')
df = pd.read_csv('cars.csv')
# Шаг 2: Подсчет количества появлений каждой марки
make_counts = df['Make'].value_counts()
# Шаг 3: Определение марки с наибольшим количеством появлений
most_common_make = make_counts.idxmax()
most_common_make_count = make_counts.max()
print(f'Самая распространенная марка автомобилей: {most_common_make} (Количество: {most_common_make_count})')
Описание шагов:

-Импортируем библиотеку pandas.
-Загружаем данные из файла 'cars.csv' в DataFrame.
-Используем метод value_counts() для подсчета количества появлений каждой марки автомобилей в столбце 'Make'.
-Метод idxmax() находит индекс (марку) с наибольшим значением, а max() возвращает это максимальное значение.

5. Для выполнения этой задачи можно использовать библиотеку Seaborn для визуализации скаттерограммы и библиотеку pandas для работы с данными. Вот шаги, которые нужно выполнить:
-Загрузите данные в DataFrame.
-Постройте скаттерограмму для столбцов 'Distance' и 'Year', используя столбец 'Transmission' для цветового кодирования (hue).
-Найдите точку, которая наиболее близка к координатам (Year = 1980, Distance = 500000).
-Определите тип Transmission для этой точки.
Пример кода:

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.spatial import KDTree
# Шаг 1: Загрузка данных в DataFrame (предположим, что данные в файле 'cars.csv')
df = pd.read_csv('cars.csv')
# Шаг 2: Построение скаттерограммы
plt.figure(figsize=(10, 6))
scatter_plot = sns.scatterplot(data=df, x='Year', y='Distance', hue='Transmission', palette='viridis')
plt.title('Scatter Plot of Distance vs Year with Transmission as Hue')
plt.show()
# Шаг 3: Поиск точки, ближайшей к координатам (Year = 1980, Distance = 500000)
# Создаем KDTree для быстрого поиска ближайших точек
tree = KDTree(df[['Year', 'Distance']])
dist, idx = tree.query([[1980, 500000]], k=1)
nearest_point = df.iloc[idx[0]]
nearest_transmission = nearest_point['Transmission']
print(f'Тип Transmission для точки, ближайшей к (Year = 1980, Distance = 500000): {nearest_transmission}')
Описание шагов:
-Импортируйте необходимые библиотеки: pandas для работы с данными, seaborn и matplotlib для визуализации, и scipy.spatial.KDTree для поиска ближайших точек.
-Загрузите данные из файла 'cars.csv' в DataFrame.
-Постройте скаттерограмму с помощью функции scatterplot из библиотеки Seaborn, указав 'Year' по оси x, 'Distance' по оси y и 'Transmission' в качестве цветового кодирования (hue).
-Используйте KDTree для поиска ближайшей точки к координатам (1980, 500000). KDTree позволяет быстро находить ближайшие точки в многомерном пространстве.
-Извлеките тип Transmission для найденной ближайшей точки и выведите его.

6. Если взять новым признаком координаты полученные при конструировании признаков, то в случае левого графика у красных данных перемноженные координаты будут иметь отрицательный знак, у синих же всегда положительный, в таком случае мы получим новую характеристику и по ней сможем отделить одной линией. Для правого же графика стоит также взять за основу коордиинаты и вычислить с помощью них расстояние до начала координат по формуле d=sqrt(x^2+y^2), найти наибольшее расстояние для красных признаков и наименьшее для синих, далее путём сравнения мы также сможем отделить их одной линией
